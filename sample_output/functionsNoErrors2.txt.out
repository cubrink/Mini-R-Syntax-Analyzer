TOKEN: IF                   LEXEME: if
TOKEN: LPAREN               LEXEME: (
TOKEN: TRUE                 LEXEME: TRUE
CONST -> TRUE
FACTOR -> CONST
TOKEN: RPAREN               LEXEME: )
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
COND_IF -> IF ( EXPR
TOKEN: LBRACE               LEXEME: {
TOKEN: IDENT                LEXEME: cranberry
TOKEN: LPAREN               LEXEME: (
TOKEN: IDENT                LEXEME: one
TOKEN: COMMA                LEXEME: ,
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
FACTOR -> VAR
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
TOKEN: IDENT                LEXEME: two
TOKEN: COMMA                LEXEME: ,
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
FACTOR -> VAR
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
TOKEN: IDENT                LEXEME: three
TOKEN: RPAREN               LEXEME: )
ENTIRE_VAR -> IDENT
VAR -> ENTIRE_VAR
FACTOR -> VAR
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
ARGS -> EXPR
ARGS -> EXPR, ARGS
ARGS -> EXPR, ARGS
ARG_LIST -> ARGS
FUNCTION_CALL -> IDENT ( ARG_LIST )
EXPR -> FUNCTION_CALL
TOKEN: RBRACE               LEXEME: }
EXPR_LIST -> epsilon
COMPOUND_EXPR -> { EXPR EXPR_LIST }
EXPR -> COMPOUND_EXPR
THEN_EXPR -> EXPR
TOKEN: ELSE                 LEXEME: else
TOKEN: LBRACE               LEXEME: {
TOKEN: IDENT                LEXEME: blueberry
TOKEN: LPAREN               LEXEME: (
TOKEN: RPAREN               LEXEME: )
NO_ARGS -> epsilon
ARG_LIST -> NO_ARGS
FUNCTION_CALL -> IDENT ( ARG_LIST )
EXPR -> FUNCTION_CALL
TOKEN: SEMICOLON            LEXEME: ;
TOKEN: IDENT                LEXEME: watermelon
TOKEN: ASSIGN               LEXEME: =
INDEX ->  epsilon
TOKEN: FLOATCONST           LEXEME: 7.894
CONST -> FLOATCONST
FACTOR -> CONST
TOKEN: SEMICOLON            LEXEME: ;
MULT_OP_LIST -> epsilon
TERM -> FACTOR MULT_OP_LIST
ADD_OP_LIST -> epsilon
SIMPLE_ARITHLOGIC -> TERM ADD_OP_LIST
ARITHLOGIC_EXPR -> SIMPLE_ARITHLOGIC
EXPR -> ARITHLOGIC_EXPR
ASSIGNMENT_EXPR -> IDENT INDEX = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: IDENT                LEXEME: strawberry
TOKEN: ASSIGN               LEXEME: =
INDEX ->  epsilon
TOKEN: READ                 LEXEME: read
TOKEN: LPAREN               LEXEME: (
TOKEN: RPAREN               LEXEME: )
INPUT_EXPR -> READ ( )
EXPR -> INPUT_EXPR
ASSIGNMENT_EXPR -> IDENT INDEX = EXPR
EXPR -> ASSIGNMENT_EXPR
TOKEN: RBRACE               LEXEME: }
EXPR_LIST -> epsilon
EXPR_LIST -> ; EXPR EXPR_LIST
EXPR_LIST -> ; EXPR EXPR_LIST
COMPOUND_EXPR -> { EXPR EXPR_LIST }
EXPR -> COMPOUND_EXPR
IF_EXPR -> COND_IF ) THEN_EXPR ELSE EXPR
EXPR -> IF_EXPR
START -> EXPR

---- Completed parsing ----

